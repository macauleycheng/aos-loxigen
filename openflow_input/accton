// Copyright 2014, Big Switch Networks, Inc.
//
// LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
// the following special exception:
//
// LOXI Exception
//
// As a special exception to the terms of the EPL, you may distribute libraries
// generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
// that copyright and licensing notices generated by LoxiGen are not altered or removed
// from the LoxiGen Libraries and the notice provided below is (i) included in
// the LoxiGen Libraries, if distributed in source code form and (ii) included in any
// documentation for the LoxiGen Libraries, if distributed in binary form.
//
// Notice: "Copyright 2014, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//
// You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
// a copy of the EPL at:
//
// http://www.eclipse.org/legal/epl-v10.html
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// EPL for the specific language governing permissions and limitations
// under the EPL.

#version 4

//accton
enum ofp_experimenter_command_accton {
    OFPEC_QUEUE_RATE = 0, /* Set queue rate */
    OFPFC_QUEUE_WRED = 1  /* Set queue WRED */
};

struct of_accton_header : of_experimenter {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x7072cf;
    uint32_t subtype == ?;
};

struct of_accton_set_queue_rate_request : of_accton_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x7072cf;
    uint32_t subtype == 0;

    uint32_t port;
    pad(4);

    list(of_packet_queue_t) queues;
};

struct of_accton_set_queue_wred_request : of_accton_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x7072cf;
    uint32_t subtype == 1;

    uint32_t port;
    pad(4);

    list(of_packet_queue_t) queues;
};

enum ofp_accton_queue_properties_wred {
    OFPQT_WRED_MIN_THRESHOLD = 1, /* Minimum threshold */
    OFPQT_WRED_MAX_THRESHOLD = 2, /* Maximum threshold */
    OFPQT_WRED_ECN_THRESHOLD = 3, /* ECN threshold */
    OFPQT_WRED_DROP_PROB = 4 /* drop probability */
};

struct of_queue_prop_experimenter_wred : of_queue_prop_experimenter {
    uint16_t type == 65535;
    uint16_t len;
    pad(4);
    uint32_t experimenter == 0x7072cf;
    uint16_t exp_type;
    uint16_t percentage;
};


enum accton_match_exp_type {
    ACCTON_OXM_INPORTS = 1,
    ACCTON_OXM_UDF_OFFSET = 2,
    ACCTON_OXM_UDF_DATA = 3
};

struct of_oxm_accton : of_oxm_experimenter {
    uint32_t type_len == 0xffff0000;
    uint32_t experimenter == 0x7072cf;
    uint16_t subtype == ?;
    of_octets_t value;
};

// ACCTON_OXM_INPORTS
struct of_oxm_accton_inports : of_oxm_accton {
    uint32_t type_len == 0xffff000e;
    uint32_t experimenter == 0x7072cf;
    uint16_t subtype == 1;
    uint64_t value;
};

// ACCTON_OXM_UDF_OFFSET
struct of_oxm_accton_udf_offset : of_oxm_accton {
    uint32_t type_len == 0xffff0008;
    uint32_t experimenter == 0x7072cf;
    uint16_t subtype == 2;
    uint16_t value;
};

// ACCTON_OXM_UDF_DATA
struct of_oxm_accton_udf_data : of_oxm_accton {
    uint32_t type_len == 0xffff000a;
    uint32_t experimenter == 0x7072cf;
    uint16_t subtype == 3;
    uint32_t value;
};

struct of_oxm_accton_udf_data_masked : of_oxm_accton {
    uint32_t type_len == 0xffff010e;
    uint32_t experimenter == 0x7072cf;
    uint16_t subtype == 3;
    uint32_t value;
    uint32_t value_mask;
};

